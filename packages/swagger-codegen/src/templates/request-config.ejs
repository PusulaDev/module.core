<%
const { utils, route, config, modelTypes } = it;
const { requestBodyInfo, responseBodyInfo, specificArgNameResolver } = route;
const {_, getInlineParseContent, getParseContent, parseSchema, getComponentByRef, require} = utils;
const { path, method, payload, query, formData, security, requestParams, pathParams } = route.request;

const securityTmpl = security ? 'true' : null;
const requestTypes = [];
const queryKeys = []

if (payload)
{
    requestTypes.push(payload.type)
}

if (requestParams)
{
    requestTypes.push(getInlineParseContent(requestParams))
    const requestParamContract = modelTypes.find(e=> e.name === getInlineParseContent(requestParams));
    console.log('param contract',getInlineParseContent(requestParams),requestParamContract.properties)
    Object.values(requestParamContract.properties).forEach(item => {
        if(item.in === "query") queryKeys.push(item.name);
    })

    console.log('query keys',queryKeys);
}

if (pathParams)
{
    requestTypes.push(pathParams.type);
}

let validationProperties = [];

const contracts = modelTypes.filter(e=> requestTypes.includes(e.name))

contracts.forEach(contract => {
    contract?.rawContent?.forEach(field => {
        if(validationProperties.some(e=>e.name === field.name)) return;

        const rules = {
            isRequired: field.isRequired,
            maxLength: field.maxLength,
            minLength: field.minLength,
            minimum: field.minimum,
            maximum: field.maximum,
            exclusiveMinimum: field.exclusiveMinimum,
            exclusiveMaximum: field.exclusiveMaximum,
            pattern: field.pattern,
            uniqueItems: field.uniqueItems,
        };

        const hasAnyRule = Object.values(rules).some(e=>Boolean(e))
        
        if(hasAnyRule)
            validationProperties.push({
                name:field.name.replaceAll('"',''),
                type:field.type,
                rules
            })
    })
})

   

let requestType = requestTypes.join(' & ') || 'undefined';

const responseType = route.response.type;

const requestContentKind = {
    "JSON": "EnumContentType.Json",
    "URL_ENCODED": "EnumContentType.UrlEncoded",
    "FORM_DATA": "EnumContentType.FormData",
    "TEXT": "EnumContentType.Text",
}

const responseContentKind = {
    "TEXT": "EnumResponseFormat.Text",
    "JSON": "EnumResponseFormat.Json",
    "IMAGE": "EnumResponseFormat.Blob",
    "FORM_DATA": "EnumResponseFormat.FormData"
}

const bodyContentKindTmpl = requestContentKind[requestBodyInfo.contentKind] || null;
const format = responseBodyInfo.success && responseBodyInfo.success.schema && responseBodyInfo.success.schema.contentKind;
const responseFormatTmpl = responseContentKind[responseBodyInfo.success && responseBodyInfo.success.schema && responseBodyInfo.success.schema.contentKind] || null;
const requestName = route.routeName.usage;
%>

const <% ~requestName %>Config: ICachableRequestConfig<<% ~requestType %>, <% ~responseType %>> = {
  url: "<% ~path %>",
  cacheKey: "<% ~requestName %>",
  <%~ bodyContentKindTmpl ? `headers : { [contentTypeKey]: ${bodyContentKindTmpl} },` : '' %>
  <%~ responseFormatTmpl ? `responseFormat: ${responseFormatTmpl},` : '' %>
  <%~ validationProperties ? `validationProperties: ${JSON.stringify(validationProperties)},` : ''  %>
  };